// utils.js
// Shared utility functions for the ESBD project.

export function describeCurveType(curveType) {
    switch (curveType) {
        case 'potential':
            return 'electrochemical potential';
            break;
        case 'standardState':
            return 'standard state potential';
            break;
        case 'bandEdge_C':
            return 'conduction band edge ($E_\\mathrm{C}$)';
            break;
        case 'bandEdge_V':
            return 'valence band edge ($E_\\mathrm{V}$)';
            break;
        case 'phi':
            return 'electrostatic potential';
            break;
        default:
            return 'unknown';
            break;
    }
}

/**
 * Creates the base HTML content for a popup based on diagram info object.
 * Generic version that does not depend on external config.
 * @param {object} info - The info object from the ESBD callback.
 * Expected fields: labelString, speciesId, traceId, curveType,
 * xValue, yValueDisplayed, currentMode, regionInfo.
 * @returns {string} - Basic HTML string for the popup, using KaTeX delimiters.
 */
export function formatPopupBaseContent(info) {
    let label = info.label; // The KaTeX string generated by the module (no delimiters)
    if (label) {
        label = `$${label}$`; // Add delimiters for KaTeX auto-render
    } else {
        // Fallback using speciesId or traceId if label is null/undefined
        label = info.speciesId || info.traceId || 'Trace';
    }

    const description = info.curveDescription;
    // --- Format Title Line ---
    // REFACTOR: Assemble title line separately
    const titleLine = `<b>${label}</b>: ${description}`;

    // Format position
    let positionStr = `x = ${info.xValue?.toFixed(3)}`; // Add optional chaining

    // Format value
    let valueStr = `y = ${info.yValue.toFixed(3)}&nbsp;V`;

    // Format region
    let regionStr = '';
    if (info.regionInfo) {
        regionStr = `Region: ${info.regionInfo.name} (#${info.regionIndex})`;
    }

    // Assemble Final Content
    let content = titleLine;
    content += `<br>${positionStr}`;
    content += `<br>${valueStr}`;
    if (regionStr) content += `<br>${regionStr}`;

    return content;
}

// ========================================================================
// Debounce and Throttle Utilities
// Based on common patterns (similar to Lodash implementations)
// ========================================================================

/**
 * Creates a debounced function that delays invoking func until after wait milliseconds
 * have elapsed since the last time the debounced function was invoked.
 * Includes a .cancel() method to cancel delayed func invocations.
 * @param {Function} func The function to debounce.
 * @param {number} wait The number of milliseconds to delay.
 * @returns {Function & { cancel: () => void }} Returns the new debounced function with a cancel method.
 */
export function debounce(func, wait) {
    let timeoutId = null; // Store timeout ID accessible by returned function and cancel method

    const debounced = function executedFunction(...args) {
        const context = this;
        const later = () => {
            timeoutId = null;
            func.apply(context, args);
        };
        clearTimeout(timeoutId);
        timeoutId = setTimeout(later, wait);
    };

    debounced.cancel = function () {
        clearTimeout(timeoutId);
        timeoutId = null;
    };

    return debounced;
}

/**
 * Creates a throttled function that only invokes func at most once per every wait milliseconds.
 * Includes options for leading and trailing calls and a .cancel() method.
 * @param {Function} func The function to throttle.
 * @param {number} wait The number of milliseconds to throttle invocations to.
 * @param {object} [options={}] Optional configuration.
 * @param {boolean} [options.leading=true] Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true] Specify invoking on the trailing edge of the timeout.
 * @returns {Function & { cancel: () => void }} Returns the new throttled function with a cancel method.
 */
export function throttle(func, wait, options = {}) {
    let context, args, result;
    let timeoutId = null;
    let previous = 0; // Timestamp of the last execution
    if (!options) options = {};
    const leading = options.leading !== false; // Default true
    const trailing = options.trailing !== false; // Default true

    const later = function () {
        previous = leading === false ? 0 : Date.now(); // Reset previous if leading is false
        timeoutId = null;
        result = func.apply(context, args); // Execute the function
        if (!timeoutId) context = args = null; // Clear references if no pending timeout
    };

    const throttled = function () {
        const now = Date.now();
        // If leading is false and this is the first call, set previous to now
        if (!previous && leading === false) previous = now;

        const remaining = wait - (now - previous);
        context = this;
        args = arguments;

        if (remaining <= 0 || remaining > wait) {
            // If time expired or system clock changed drastically
            if (timeoutId) {
                clearTimeout(timeoutId);
                timeoutId = null;
            }
            previous = now;
            result = func.apply(context, args); // Execute immediately
            if (!timeoutId) context = args = null;
        } else if (trailing && !timeoutId) {
            // Schedule trailing call if option enabled and no timer currently pending
            timeoutId = setTimeout(later, remaining);
        }
        return result;
    };

    throttled.cancel = function () {
        clearTimeout(timeoutId);
        previous = 0;
        timeoutId = context = args = null;
    };

    return throttled;
}

/**
 * Renders LaTeX mathmode inside a given span element, but only if the new label
 * text is different from the previously rendered text (stored in dataset).
 * Handles clearing old content and potential KaTeX errors.
 * @param {HTMLSpanElement} spanElement - The target span element.
 * @param {string | null | undefined} newLabelText - The raw LaTeX string (no delimiters) or null/empty to clear.
 * @param {boolean} textMode - Start in text mode or in math mode (default).
 * @param {boolean} forceRender - Render anyway even if label was unchanged.
 */
export function renderSpanMath(
    spanElement,
    newLabelText,
    textMode = false,
    forceRender = false
) {
    if (!spanElement) return; // Safety check

    const currentLabel = newLabelText ?? '';

    if (typeof katex === 'undefined') {
        // Caller forgot to load katex
        spanElement.textContent = currentLabel;
        return;
    }

    // For text mode, we also need the auto-render extension.
    if (textMode && typeof renderMathInElement === 'undefined') {
        console.warn(
            'KaTeX auto-render extension not loaded for text mode rendering.'
        );
        spanElement.innerHTML = currentLabel;
        return;
    }

    const previousLabel = spanElement.dataset.renderedLabel || '';
    const currentMode = textMode ? 'text' : 'math';
    const previousMode = spanElement.dataset.renderedMode || currentMode;

    // Avoid re-rendering if no change in content or mode
    if (
        currentLabel === previousLabel &&
        currentMode === previousMode &&
        !forceRender
    )
        return;

    // Update stored label and mode first
    spanElement.dataset.renderedLabel = currentLabel;
    spanElement.dataset.renderedMode = currentMode;

    // Clear existing content
    spanElement.innerHTML = '';
    if (!currentLabel) return;

    try {
        if (textMode) {
            spanElement.innerHTML = currentLabel;
            renderMathInElement(spanElement, {
                delimiters: [{ left: '$', right: '$', display: false }],
                throwOnError: false,
            });
        } else {
            katex.render(currentLabel, spanElement, {
                throwOnError: false,
                displayMode: false,
            });
        }
    } catch (e) {
        console.error('KaTeX render error:', e, '| Input:', currentLabel);
        spanElement.textContent = currentLabel; // Fallback on error
    }
}

// ========================================================================
// Numerics
// ========================================================================

export function linspace(start, end, numPoints) {
    if (numPoints < 2) {
        return numPoints === 1 ? [start] : [];
    }
    const arr = [];
    const step = (end - start) / (numPoints - 1);
    for (let i = 0; i < numPoints; i++) {
        arr.push(start + step * i);
    }
    return arr;
}

// ========================================================================
// D3 helpers
// ========================================================================

/**
 * Helper for properly fading in and fading out elements.
 *
 * - Double fade suppression: does not fade in children that enter at the same time as parents which are anyway fading in.
 * - No zombies: exiting elements have class removed so they can't be re-selected.
 */
export class Fader {
    /**
     *
     * @param {number} duration - milliseconds.
     * @param {d3.ease} [ease] - d3 easing function.
     * @param {string} [transitionName] - set the d3 transition name for fading in/out.
     * @param {string} [noFadeClass] - used to suppress double fades.
     */

    constructor(
        duration,
        ease = d3.easeLinear,
        transitionName = 'fade',
        noFadeClass = 'no-fade-in-children'
    ) {
        this.duration = duration;
        this.ease = ease;
        this.transitionName = transitionName;
        this.noFadeClass = noFadeClass;
    }

    /**
     * A substitute for append that performs a fade-in. Usually used during
     * the first parameter to .join().
     *
     * Immediate non-fade version would be:
     *      enterSelection.append(elementType).classed(className,true)
     *
     * @param {d3.selection} enterSelection
     * @param {string} elementType
     * @param {string} className
     */
    append(enterSelection, elementType, className) {
        const newElements = enterSelection.append(elementType);
        if (newElements.empty()) return newElements;

        newElements.classed(className, true);

        const noFadeClass = this.noFadeClass;

        // Find which elements to fade in. If an ancestor has just started to
        // fade in, then we should just appear directly (no double fade).
        const elementsToFade = newElements.filter(function (d, i, nodes) {
            // `this` is our DOM node.
            return !this.parentNode.closest('.' + noFadeClass);
        });

        if (!elementsToFade.empty())
            elementsToFade
                .attr('opacity', 0)
                .classed(noFadeClass, true) // Ask our children to not fade in.
                .transition(this.transitionName)
                .duration(this.duration)
                .ease(this.ease)
                .attr('opacity', 1)
                .on('start', function (d, i, nodes) {
                    // One frame after we enter, now children are allowed to
                    // fade in. `this` is our DOM node.
                    this.classList.remove(noFadeClass);
                });

        return newElements;
    }

    /**
     * You can use this directly as the first argument to .join().
     * Shorthand for:
     *   (enter) => this.append(enter, elementType, className).call(initialSetter)
     */
    enterAppend(elementType, className, initialSetter = null) {
        if (initialSetter)
            return (enter) =>
                this.append(enter, elementType, className).call(initialSetter);
        else return (enter) => this.append(enter, elementType, className);
    }

    /**
     * A substitute for remove that performs a fade-out before removing.
     * Includes 'de-zombifying' logic which requires className.
     *
     * Immediate non-fade version would be: exitSelection.remove()
     *
     * IMPORTANT: when selectAll()ing your elements for the data().join.(),
     * you must use selectAll('.<className>'). Otherwise the element for a
     * given ID can get "re-created" during the fade-out, and then the
     * re-created element will continue the fade-out and disappear.
     *
     * @param {d3.selection} exitSelection
     * @param {string} className
     */
    remove(exitSelection, className) {
        if (exitSelection.empty()) return exitSelection;

        exitSelection
            .classed(className, false)
            .transition(this.transitionName)
            .duration(this.duration)
            .ease(this.ease)
            .attr('opacity', 0)
            .remove();
        // return value is usually unused, but try to mimic .remove()
        // by returning a non-transition selection.
        return exitSelection;
    }

    /**
     * You can use this directly as the third argument to .join().
     * Shorthand for:
     *   (exit) => this.remove(exit, className)
     */
    exitRemove(className) {
        return (exit) => this.remove(exit, className);
    }
}
