// utils.js
// Shared utility functions for the ESBD project.

import { render as katexRender } from 'katex';
import renderMathInElement from 'katex/contrib/auto-render';

export function describeCurveType(curveType) {
    switch (curveType) {
        case 'potential':
            return 'electrochemical potential';
            break;
        case 'standardState':
            return 'standard state potential';
            break;
        case 'bandEdge_C':
            return 'conduction band edge ($E_\\mathrm{C}$)';
            break;
        case 'bandEdge_V':
            return 'valence band edge ($E_\\mathrm{V}$)';
            break;
        case 'phi':
            return 'electrostatic potential';
            break;
        default:
            return 'unknown';
            break;
    }
}

/**
 * Creates the base HTML content for a popup based on diagram info object.
 * Generic version that does not depend on external config.
 * @param {object} info - The info object from the ESBD callback.
 * Expected fields: labelString, speciesId, traceId, curveType,
 * xValue, yValueDisplayed, currentMode, regionInfo.
 * @returns {string} - Basic HTML string for the popup, using KaTeX delimiters.
 */
export function formatPopupBaseContent(info) {
    let label = info.label; // The KaTeX string generated by the module (no delimiters)
    if (label) {
        label = `$${label}$`; // Add delimiters for KaTeX auto-render
    } else {
        // Fallback using speciesId or traceId if label is null/undefined
        label = info.speciesId || info.traceId || 'Trace';
    }

    const description = info.curveDescription;
    // --- Format Title Line ---
    // REFACTOR: Assemble title line separately
    const titleLine = `<b>${label}</b>: ${description}`;

    // Format position
    let positionStr = `x = ${info.xValue?.toFixed(3)}`; // Add optional chaining

    // Format value
    let valueStr = `y = ${info.yValue.toFixed(3)}&nbsp;V`;

    // Format region
    let regionStr = '';
    if (info.regionInfo) {
        regionStr = `Region: ${info.regionInfo.name} (#${info.regionIndex})`;
    }

    // Assemble Final Content
    let content = titleLine;
    content += `<br>${positionStr}`;
    content += `<br>${valueStr}`;
    if (regionStr) content += `<br>${regionStr}`;

    return content;
}

// ========================================================================
// Debounce and Throttle Utilities
// Based on common patterns (similar to Lodash implementations)
// ========================================================================

/**
 * Creates a debounced function that delays invoking func until after wait milliseconds
 * have elapsed since the last time the debounced function was invoked.
 * Includes a .cancel() method to cancel delayed func invocations.
 * @param {Function} func The function to debounce.
 * @param {number} wait The number of milliseconds to delay.
 * @returns {Function & { cancel: () => void }} Returns the new debounced function with a cancel method.
 */
export function debounce(func, wait) {
    let timeoutId = null; // Store timeout ID accessible by returned function and cancel method

    const debounced = function executedFunction(...args) {
        const context = this;
        const later = () => {
            timeoutId = null;
            func.apply(context, args);
        };
        clearTimeout(timeoutId);
        timeoutId = setTimeout(later, wait);
    };

    debounced.cancel = function () {
        clearTimeout(timeoutId);
        timeoutId = null;
    };

    return debounced;
}

/**
 * Creates a throttled function that only invokes func at most once per every wait milliseconds.
 * Includes options for leading and trailing calls and a .cancel() method.
 * @param {Function} func The function to throttle.
 * @param {number} wait The number of milliseconds to throttle invocations to.
 * @param {object} [options={}] Optional configuration.
 * @param {boolean} [options.leading=true] Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true] Specify invoking on the trailing edge of the timeout.
 * @returns {Function & { cancel: () => void }} Returns the new throttled function with a cancel method.
 */
export function throttle(func, wait, options = {}) {
    let context, args, result;
    let timeoutId = null;
    let previous = 0; // Timestamp of the last execution
    if (!options) options = {};
    const leading = options.leading !== false; // Default true
    const trailing = options.trailing !== false; // Default true

    const later = function () {
        previous = leading === false ? 0 : Date.now(); // Reset previous if leading is false
        timeoutId = null;
        result = func.apply(context, args); // Execute the function
        if (!timeoutId) context = args = null; // Clear references if no pending timeout
    };

    const throttled = function () {
        const now = Date.now();
        // If leading is false and this is the first call, set previous to now
        if (!previous && leading === false) previous = now;

        const remaining = wait - (now - previous);
        context = this;
        args = arguments;

        if (remaining <= 0 || remaining > wait) {
            // If time expired or system clock changed drastically
            if (timeoutId) {
                clearTimeout(timeoutId);
                timeoutId = null;
            }
            previous = now;
            result = func.apply(context, args); // Execute immediately
            if (!timeoutId) context = args = null;
        } else if (trailing && !timeoutId) {
            // Schedule trailing call if option enabled and no timer currently pending
            timeoutId = setTimeout(later, remaining);
        }
        return result;
    };

    throttled.cancel = function () {
        clearTimeout(timeoutId);
        previous = 0;
        timeoutId = context = args = null;
    };

    return throttled;
}

/**
 * Renders LaTeX mathmode inside a given span element, but only if the new label
 * text is different from the previously rendered text (stored in dataset).
 * Handles clearing old content and potential KaTeX errors.
 * @param {HTMLSpanElement} spanElement - The target span element.
 * @param {string | null | undefined} newLabelText - The raw LaTeX string (no delimiters) or null/empty to clear.
 * @param {boolean} textMode - Start in text mode or in math mode (default).
 * @param {boolean} forceRender - Render anyway even if label was unchanged.
 */
export function renderSpanMath(
    spanElement,
    newLabelText,
    textMode = false,
    forceRender = false
) {
    if (!spanElement) return; // Safety check

    const currentLabel = newLabelText ?? '';

    if (typeof katexRender === 'undefined') {
        // Caller forgot to load katex
        spanElement.textContent = currentLabel;
        return;
    }

    // For text mode, we also need the auto-render extension.
    if (textMode && typeof renderMathInElement === 'undefined') {
        console.warn(
            'KaTeX auto-render extension not loaded for text mode rendering.'
        );
        spanElement.innerHTML = currentLabel;
        return;
    }

    const previousLabel = spanElement.dataset.renderedLabel || '';
    const currentMode = textMode ? 'text' : 'math';
    const previousMode = spanElement.dataset.renderedMode || currentMode;

    // Avoid re-rendering if no change in content or mode
    if (
        currentLabel === previousLabel &&
        currentMode === previousMode &&
        !forceRender
    )
        return;

    // Update stored label and mode first
    spanElement.dataset.renderedLabel = currentLabel;
    spanElement.dataset.renderedMode = currentMode;

    // Clear existing content
    spanElement.innerHTML = '';
    if (!currentLabel) return;

    try {
        if (textMode) {
            spanElement.innerHTML = currentLabel;
            renderMathInElement(spanElement, {
                delimiters: [{ left: '$', right: '$', display: false }],
                throwOnError: false,
            });
        } else {
            katexRender(currentLabel, spanElement, {
                throwOnError: false,
                displayMode: false,
            });
        }
    } catch (e) {
        console.error('KaTeX render error:', e, '| Input:', currentLabel);
        spanElement.textContent = currentLabel; // Fallback on error
    }
}

// ========================================================================
// Numerics
// ========================================================================

export function linspace(start, end, numPoints) {
    if (numPoints < 2) {
        return numPoints === 1 ? [start] : [];
    }
    const arr = [];
    const step = (end - start) / (numPoints - 1);
    for (let i = 0; i < numPoints; i++) {
        arr.push(start + step * i);
    }
    return arr;
}
