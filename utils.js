// utils.js
// Shared utility functions for the ESBD project.

export function describeCurveType(curveType) {
    switch (curveType) {
        case 'potential':
            return 'electrochemical potential';
            break;
        case 'standardState':
            return 'standard state potential';
            break;
        case 'bandEdge_C':
            return 'conduction band edge ($E_\\mathrm{C}$)';
            break;
        case 'bandEdge_V':
            return 'valence band edge ($E_\\mathrm{V}$)';
            break;
        case 'phi':
            return 'electrostatic potential';
            break;
        default:
            return 'unknown';
            break;
    }
}

/**
 * Creates the base HTML content for a popup based on diagram info object.
 * Generic version that does not depend on external config.
 * @param {object} info - The info object from the ESBD callback.
 * Expected fields: labelString, speciesId, traceId, curveType,
 * xValue, yValueDisplayed, currentMode, regionInfo.
 * @returns {string} - Basic HTML string for the popup, using KaTeX delimiters.
 */
export function formatPopupBaseContent(info) {
    let label = info.labelString; // The KaTeX string generated by the module (no delimiters)
    if (label) {
        label = `$${label}$`; // Add delimiters for KaTeX auto-render
    } else {
        // Fallback using speciesId or traceId if labelString is null/undefined
        label = info.speciesId || info.traceId || 'Trace';
    }

    const description = describeCurveType(info.curveType);
    // --- Format Title Line ---
    // REFACTOR: Assemble title line separately
    const titleLine = `<b>${label}</b>: ${description}`;

    // Format position
    let positionStr = `x = ${info.xValue?.toFixed(3)}`; // Add optional chaining

    // Format value
    let valueStr = '';
    const mode = info.currentMode;
    const val = info.yValueDisplayed;
    if (val !== null && isFinite(val)) {
        valueStr = `${mode} = ${val.toFixed(3)} ${mode === 'kJmol' ? 'kJ/mol' : mode}`;
    } else {
        valueStr = `${mode} = N/A`;
    }

    // Format region
    let regionStr = '';
    if (info.regionInfo) {
        regionStr = `Region: ${info.regionInfo.name} (#${info.regionIndex})`;
    }

    // Assemble Final Content
    let content = titleLine;
    content += `<br>${positionStr}`;
    content += `<br>${valueStr}`;
    if (regionStr) content += `<br>${regionStr}`;

    return content;
}

// ========================================================================
// Debounce and Throttle Utilities
// Based on common patterns (similar to Lodash implementations)
// ========================================================================

/**
 * Creates a debounced function that delays invoking func until after wait milliseconds
 * have elapsed since the last time the debounced function was invoked.
 * Includes a .cancel() method to cancel delayed func invocations.
 * @param {Function} func The function to debounce.
 * @param {number} wait The number of milliseconds to delay.
 * @returns {Function & { cancel: () => void }} Returns the new debounced function with a cancel method.
 */
export function debounce(func, wait) {
    let timeoutId = null; // Store timeout ID accessible by returned function and cancel method

    const debounced = function executedFunction(...args) {
        const context = this;
        const later = () => {
            timeoutId = null;
            func.apply(context, args);
        };
        clearTimeout(timeoutId);
        timeoutId = setTimeout(later, wait);
    };

    debounced.cancel = function () {
        clearTimeout(timeoutId);
        timeoutId = null;
    };

    return debounced;
}

/**
 * Creates a throttled function that only invokes func at most once per every wait milliseconds.
 * Includes options for leading and trailing calls and a .cancel() method.
 * @param {Function} func The function to throttle.
 * @param {number} wait The number of milliseconds to throttle invocations to.
 * @param {object} [options={}] Optional configuration.
 * @param {boolean} [options.leading=true] Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true] Specify invoking on the trailing edge of the timeout.
 * @returns {Function & { cancel: () => void }} Returns the new throttled function with a cancel method.
 */
export function throttle(func, wait, options = {}) {
    let context, args, result;
    let timeoutId = null;
    let previous = 0; // Timestamp of the last execution
    if (!options) options = {};
    const leading = options.leading !== false; // Default true
    const trailing = options.trailing !== false; // Default true

    const later = function () {
        previous = leading === false ? 0 : Date.now(); // Reset previous if leading is false
        timeoutId = null;
        result = func.apply(context, args); // Execute the function
        if (!timeoutId) context = args = null; // Clear references if no pending timeout
    };

    const throttled = function () {
        const now = Date.now();
        // If leading is false and this is the first call, set previous to now
        if (!previous && leading === false) previous = now;

        const remaining = wait - (now - previous);
        context = this;
        args = arguments;

        if (remaining <= 0 || remaining > wait) {
            // If time expired or system clock changed drastically
            if (timeoutId) {
                clearTimeout(timeoutId);
                timeoutId = null;
            }
            previous = now;
            result = func.apply(context, args); // Execute immediately
            if (!timeoutId) context = args = null;
        } else if (trailing && !timeoutId) {
            // Schedule trailing call if option enabled and no timer currently pending
            timeoutId = setTimeout(later, remaining);
        }
        return result;
    };

    throttled.cancel = function () {
        clearTimeout(timeoutId);
        previous = 0;
        timeoutId = context = args = null;
    };

    return throttled;
}
