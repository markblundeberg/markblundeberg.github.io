// utils.js
// Shared utility functions for the ESBD project.

export function describeCurveType(curveType) {
    switch (curveType) {
        case 'potential':
            return 'electrochemical potential';
            break;
        case 'standardState':
            return 'standard state potential';
            break;
        case 'bandEdge_C':
            return 'conduction band edge ($E_\\mathrm{C}$)';
            break;
        case 'bandEdge_V':
            return 'valence band edge ($E_\\mathrm{V}$)';
            break;
        case 'phi':
            return 'electrostatic potential';
            break;
        default:
            return 'unknown';
            break;
    }
}

/**
 * Creates the base HTML content for a popup based on diagram info object.
 * Generic version that does not depend on external config.
 * @param {object} info - The info object from the ESBD callback.
 * Expected fields: labelString, speciesId, traceId, curveType,
 * xValue, yValueDisplayed, currentMode, regionInfo.
 * @returns {string} - Basic HTML string for the popup, using KaTeX delimiters.
 */
export function formatPopupBaseContent(info) {
    let label = info.labelString; // The KaTeX string generated by the module (no delimiters)
    if (label) {
        label = `$${label}$`; // Add delimiters for KaTeX auto-render
    } else {
        // Fallback using speciesId or traceId if labelString is null/undefined
        label = info.speciesId || info.traceId || 'Trace';
    }

    const description = describeCurveType(info.curveType);
    // --- Format Title Line ---
    // REFACTOR: Assemble title line separately
    const titleLine = `<b>${label}</b>: ${description}`;

    // Format position
    let positionStr = `x = ${info.xValue?.toFixed(3)}`; // Add optional chaining

    // Format value
    let valueStr = '';
    const mode = info.currentMode;
    const val = info.yValueDisplayed;
    if (val !== null && isFinite(val)) {
        valueStr = `${mode} = ${val.toFixed(3)} ${mode === 'kJmol' ? 'kJ/mol' : mode}`;
    } else {
        valueStr = `${mode} = N/A`;
    }

    // Format region
    let regionStr = '';
    if (info.regionInfo) {
        regionStr = `Region: ${info.regionInfo.name} (#${info.regionIndex})`;
    }

    // Assemble Final Content
    let content = titleLine;
    content += `<br>${positionStr}`;
    content += `<br>${valueStr}`;
    if (regionStr) content += `<br>${regionStr}`;

    return content;
}

/**
 * Creates a debounced function that delays invoking func until after wait milliseconds
 * have elapsed since the last time the debounced function was invoked.
 * Includes a .cancel() method to cancel delayed func invocations.
 * @param {Function} func The function to debounce.
 * @param {number} wait The number of milliseconds to delay.
 * @returns {Function & { cancel: () => void }} Returns the new debounced function with a cancel method.
 */
export function debounce(func, wait) {
    let timeoutId = null; // Store timeout ID accessible by returned function and cancel method

    const debounced = function executedFunction(...args) {
        const context = this;
        const later = () => {
            timeoutId = null;
            func.apply(context, args);
        };
        clearTimeout(timeoutId);
        timeoutId = setTimeout(later, wait);
    };

    debounced.cancel = function () {
        clearTimeout(timeoutId);
        timeoutId = null;
    };

    return debounced;
}
