// utils.js
// Shared utility functions for the ESBD project.

// Add other utility functions or constants here later if needed...
// export const MY_CONSTANT = ...;

/**
 * Creates the base HTML content for a popup based on diagram info object.
 * Generic version that does not depend on external config.
 * @param {object} info - The info object from the ESBD callback.
 * Expected fields: labelString, speciesId, traceId, curveType,
 * xValue, yValueDisplayed, currentMode, regionInfo.
 * @returns {string} - Basic HTML string for the popup, using KaTeX delimiters.
 */
export function formatPopupBaseContent(info) {
    // Use info directly
    let label = info.labelString; // The KaTeX string generated by the module (no delimiters)
    if (label) {
        label = `$${label}$`; // Add delimiters for KaTeX auto-render
    } else {
        // Fallback using speciesId or traceId if labelString is null/undefined
        label = info.speciesId || info.traceId || 'Trace';
    }

    let description = '';
    // Describe the curve type
    switch (info.curveType) {
        case 'potential':
            description = 'Electrochemical potential';
            break;
        case 'standardState':
            description = 'Standard state potential';
            break;
        case 'bandEdge_C':
            description = 'Conduction band edge ($E<sub>C</sub>$)';
            break;
        case 'bandEdge_V':
            description = 'Valence band edge ($E<sub>V</sub>$)';
            break;
        case 'phi':
            description = 'Electrostatic potential';
            break;
        default:
            description = info.curveType
                ? info.curveType.replace(/_/g, ' ')
                : info.traceId || '';
            break;
    }
    if (description) description = `: ${description}`;

    // Format position
    let positionStr = `x = ${info.xValue?.toFixed(3)}`; // Add optional chaining

    // Format value
    let valueStr = '';
    const mode = info.currentMode;
    const val = info.yValueDisplayed;
    if (val !== null && isFinite(val)) {
        valueStr = `${mode} = ${val.toFixed(3)} ${mode === 'kJmol' ? 'kJ/mol' : mode}`;
    } else {
        valueStr = `${mode} = N/A`;
    }

    // Format region
    let regionStr = '';
    if (info.regionInfo) {
        regionStr = `Region: ${info.regionInfo.name} (#${info.regionIndex})`;
    }

    // Assemble base content
    let content = `<b>${label}</b>${description}<br>${positionStr}<br>${valueStr}`;
    if (regionStr) content += `<br>${regionStr}`;

    return content;
}

/**
 * Creates a debounced function that delays invoking func until after wait milliseconds
 * have elapsed since the last time the debounced function was invoked.
 * Includes a .cancel() method to cancel delayed func invocations.
 * @param {Function} func The function to debounce.
 * @param {number} wait The number of milliseconds to delay.
 * @returns {Function & { cancel: () => void }} Returns the new debounced function with a cancel method.
 */
export function debounce(func, wait) {
    let timeoutId = null; // Store timeout ID accessible by returned function and cancel method

    const debounced = function executedFunction(...args) {
        const context = this;
        const later = () => {
            timeoutId = null;
            func.apply(context, args);
        };
        clearTimeout(timeoutId);
        timeoutId = setTimeout(later, wait);
    };

    debounced.cancel = function () {
        clearTimeout(timeoutId);
        timeoutId = null;
    };

    return debounced;
}
